<% provide(:title, 'Add new stroke order') %>
<h1>Stroke order for <%= @hanzi.character %></h1>

<div>
  <canvas id="stroke_order_canvas" height="400" width="400" class="center"></canvas>
</div>

<script>
var canvas = document.getElementById("stroke_order_canvas");
var context = canvas.getContext("2d");
var strokes = <%= @strokeorder.strokes %>;
var max_distance = 20;
var clear_distance = max_distance / 1.5;
var stroke_number = 0;

for (var i = 0; i < strokes[0].length; i++) {
    if (strokes[0][i].length > 1) {
	stroke_number++;
    }
}

function point(x, y, canvas){
    context.beginPath();
    context.arc(x, y, 1, 0, 2 * Math.PI, true);
    context.stroke();
}

// plot each individual dot
for (var i = 0; i < strokes.length; i++) {
    for (var j = 0; j < strokes[i].length; j++) {
	for (var k = 0; k < strokes[i][j].length; k++) {
	    point(strokes[i][j][k][0], strokes[i][j][k][1], canvas);
	}
    }
}

var final_strokes = [];

// getting the final points
for (var stroke_count = 0; stroke_count < stroke_number; stroke_count++) {
    // we want to consider each point only once, so we'll keep record
    var final_stroke = []
    var used_points = [];
    // get the starting point by averaging the first point of each try
    var average_x = 0;
    var average_y = 0;
    var total_points = 0;
    for (var try_count = 0; try_count < strokes.length; try_count++) {
	var point_x = strokes[try_count][stroke_count][0][0];
	var point_y = strokes[try_count][stroke_count][0][1]
	average_x += point_x;
	average_y += point_y;
	total_points += strokes[try_count][stroke_count].length;
	used_points.push([point_x, point_y].join());
    }
    average_x /= strokes.length;
    average_y /= strokes.length;

    // plot the starting point
    context.beginPath();
    context.arc(average_x, average_y, 10, 0, 2 * Math.PI, true);
    context.fillStyle = 'blue';
    context.fill();
    context.strokeStyle = 'blue';
    context.stroke();
    context.closePath();

    var last_x = average_x;
    var last_y = average_y;
    final_stroke.push([last_x, last_y]);

    // repeat this until all points have been used
    var points_left = true;
    while ((used_points.length < total_points) && (points_left)) {

	// get the distance from the starting point for each stroke point
	// but just check the points within max_distance!
	var these_points = [];
	for (var try_count = 0; try_count < strokes.length; try_count++) {
	    for (var i = 0; i < strokes[try_count][stroke_count].length; i++) {
		var x_coordinate = strokes[try_count][stroke_count][i][0];
		var y_coordinate = strokes[try_count][stroke_count][i][1];
		if (used_points.indexOf([x_coordinate, y_coordinate].join()) < 0) {
		    var rel_x = average_x - x_coordinate;
		    var rel_y = average_y - y_coordinate;
		    if ((Math.abs(rel_x) < max_distance) && (Math.abs(rel_y) < max_distance)) {
			these_points.push([x_coordinate, y_coordinate]);
			if ((Math.abs(rel_x) < clear_distance) && (Math.abs(rel_y) < clear_distance)) {			
			    used_points.push([x_coordinate, y_coordinate].join());
			}
		    }
		}
	    }
	}

	if (these_points.length == 0) {
	    points_left = false;
	    break
	}

	// average all these points
	var x = 0;
	var y = 0;
	for (var i = 0; i < these_points.length; i++) {
	    var this_x = these_points[i][0];
	    var this_y = these_points[i][1];
	    x += this_x;
	    y += this_y;
	}

	x /= these_points.length;
	y /= these_points.length;

	context.beginPath();
	context.moveTo(x, y);		
	context.lineTo(last_x, last_y);
	context.stroke()
	context.strokeStyle = 'red';
	context.stroke();
	context.closePath();

	last_x = x;	
	last_y = y;
	average_x = x;
	average_y = y;
	final_stroke.push([x, y]);
    }
    final_strokes.push(final_stroke);
}

// animating the final points
function animate_strokes() {
    var context = document.getElementById('stroke_order_canvas').getContext('2d');
    var seconds_per_stroke = 1;
    var total_time = seconds_per_stroke * final_strokes.length;

    context.globalCompositeOperation = 'destination-over';
    context.clearRect(0, 0, canvas.width, canvas.height);

    if(time.get_seconds() - zero_time > total_time) {
	zero_time = time.get_seconds();
    }

    // for each seconds_per_stroke that has passed since zero_time, draw one stroke
    for (var i = 0; i < Math.floor(time.get_seconds() / seconds_per_stroke); i++) {
	for (strokenumber = 0; strokenumber < final_strokes.length; strokenumber++) {
	    var stroke = final_strokes[strokenumber];
	}
	
    }

    // for a fraction of a seconds_per_stroke, draw a fraction of the next stroke
}

var zero_time = time.get_seconds();
window.requestAnimationFrame(animate_strokes);

</script>
